# CH 1 자바 8 ~ 11 : 무슨 일이 일어나고 있는가? 🚀

## 1.1 역사의 흐름은 무엇인가? 🌊

자바 역사를 통틀어 가장 큰 변화가 자바 8에서 일어났다.
- 🌟 스트림 API
- 🚀 메서드에 코드를 전달하는 기법
- 📌 인터페이스의 디폴트 메서드

스트림을 이용하면 에러를 자주 일으키며 멀티코어 CPU를 이용하는 것보다 비용이 훨씬 비싼 키워드 `synchronized`를 사용하지 않아도 된다.

조금 다른 관점에서 보면 결국 자바 8에 추가된 스트림 API 덕분에 다른 두 가지 기능, 즉 메서드에 코드를 전달하는 간결 기법(메서드 참조와 람다)과 인터페이스의 디폴트 메서드가 존재할 수 있음을 알 수 있다.

## 1.2 왜 아직도 자바는 변화하는가? 🤔

우리는 시공을 초월하는 완벽한 언어를 원하지만 현실적으로 그런 언어는 존재하지 않으며 모든 언어가 장단점을 갖고 있다.

### 1.2.1 프로그래밍 언어 생태계에서 자바의 위치 🌍

### 1.2.2 스트림 처리 💧

스트림이란 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임이다. 이론적으로 프로그램은 입력 스트림에서 데이터를 한 개씩 읽어 들이며 마찬가지로 출력 스트림으로 데이터를 한 개씩 기록한다. 즉, 어떤 프로그램의 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있다.

### 1.2.3 동작 파라미터화로 메서드에 코드 전달하기 💼

자바 8에 추가된 두 번째 프로그램 개념은 코드 일부를 API로 전달하는 기능이다.

자바 8에서는 메서드(우리 코드)를 다른 메서드의 인수로 넘겨주는 기능을 제공한다.

이러한 기능을 이론적으로 동작 파라미터화 behavior parameterization라고 부른다.

### 1.2.4 병렬성과 공유 가변 데이터 ⚙️

세 번째 프로그래밍의 개념은 ‘병렬성을 공짜로 얻을 수 있다’라는 말에서 시작된다. 세상에 공짜는 없다고 했는데 그럼 병렬성을 얻는 대신 무엇을 포기해야 할까? 스트림 메서드로 전달하는 코드의 동작 방식을 조금 바꿔야 한다.

### 1.2.5 자바가 진화해야 하는 이유 🌱

언어는 하드웨어나 프로그래머 기대의 변화에 부응하는 방향으로 변화해야 한다.


## 1.3 자바 함수 🔢

프로그래밍 언어에서 함수function라는 용어는 메서드method 특히 정적 메서드 static method와 같은 의미로 사용된다. 자바의 함수는 이에 더해 수학적인 함수처럼 사용되며 부작용을 일으키지 않는 함수를 의미한다. 런타임에 메서드를 전달할 수 있다면, 즉 메서드를 일급 시민으로 만들면 프로그래밍에 유용하게 활용할 수 있다.

### 1.3.1 메서드와 람다를 일급 시민으로 📚

첫 번째로 메서드 참고 method reference라는 새로운 자바 8의 기능을 소개한다.


File[] hiddenFiles = new File(".").listFiles(File::isHidden);
이미 isHidden이라는 함수는 준비되어 있으므로 자바 8의 메서드 참조method reference :: 를 이용해서 listFiles에 직접 전달할 수 있다. 여기서 메서드가 아닌 함수라는 용어를 사용했다는 사실도 주목하자. 기존에 비해 문제 자체를 더 직접적으로 설명한다는 점이 자바 8 코드의 장점이다.

## 람다 : 익명 함수 🧩
자바 8에서는 (기명 named) 메서드를 일급값으로 취급할 뿐 아니라 람다(또는 익명 함수 anonymous function)를 포함하여 함수도 값으로 취급할 수 있다.


(int x) -> x + 1

즉 ‘x’라는 인수로 호출하면 x+1을 반환’하는 동작을 수행하도록 코드를 구현할 수 있다.

## 1.3.2 코드 넘겨주기 : 예제

**프레디케이트(predicate)란 무엇인가?** 🔹

앞에서 다룬 예제에서는 `Apple::isGreenApple` 메서드를 `filterApples`로 넘겨주었다. 수학에서는 인수로 값을 받아 true나 false를 반환하는 함수를 프레디케이트라고 한다. 

## 1.3.3 메서드 전달에서 람다로

**한 번만 사용할 메서드는 따로 정의를 구현할 필요가 없다.** 🔸 

하지만 람다가 몇 줄 이상으로 길어진다면(즉, 조금 복잡한 동작을 수행하는 상황) 익명 람다보다는 코드가 수행하는 일을 잘 설명하는 이름을 가진 메서드를 정의하고 메서드 참조를 활용하는 것이 바람직하다. 코드의 명확성이 우선시되어야 한다.

## 1.4 스트림

**스트림 API의 이해** 🌊 

우선은 스트림 API를 이용하면 컬렉션 API와는 상당히 다른 방식으로 데이터를 처리할 수 있다는 사실만 기억하자. 컬렉션에서는 반복과정을 직접 처리해야 했다. `for-each` 루프를 이용해서 각 요소를 반복하면서 작업을 수행했다. 이런 방식의 반복을 외부 반복(external iteration)이라고 한다. 반면 스트림 API를 이용하면 루프를 신경 쓸 필요가 없다. 스트림 API에서는 라이브러리 내부에서 모든 데이터가 처리된다. 이와 같은 반복을 내부 반복(internal iteration)이라고 한다.

# 1.4.1 멀티스레딩은 어렵다. 🧵

자바 8은 스트림 API(`java.util.stream`)로 '컬렉션을 처리하면서 발생하는 모호함과 반복적인 코드 문제' 그리고 '멀티코어 활용 어려움'이라는 두 가지 문제를 모두 해결했다. 기존의 컬렉션에서는 데이터를 처리할 때 반복되는 패턴이 너무 많았다. 따라서 라이브러리에서 이러한 반복되는 패턴을 제공한다면 좋을 것이라는 아이디어가 변화의 동기가 되었다.

컬렉션은 어떻게 데이터를 저장하고 접근할지에 중점을 두는 반면, 스트림은 데이터에 어떤 계산을 할 것인지 묘사하는 것에 중점을 둔다는 점을 기억하자. 스트림은 스트림 내의 요소를 쉽게 병렬로 처리할 수 있는 환경을 제공한다는 것이 핵심이다.

다음은 순차 처리 방식의 코드 예시입니다.


import static java.util.stream.Collectors.toList;
List<Apple> heavyApples = 
    inventory.stream().filter((Apple a) -> a.getWeight() > 150).collect(toList());

다음은 병렬 처리 방식의 코드 예시입니다.


import static java.util.stream.Collectors.toList;
List<Apple> heavyApples =
    inventory.parallelStream().filter((Apple a) -> a.getWeight() > 150).collect(toList());

## 1.5 디폴트 메서드와 자바 모듈 🔄


List<Apple> heavyApples1 =
    inventory.stream().filter((Apple a) -> a.getWeight() > 150).collect(toList());
List<Apple> heavyApples2 =
    inventory.parallelStream().filter((Apple a) -> a.getWeight() > 150).collect(toList());

디폴트 메서드를 이용하면 기존의 코드를 건드리지 않고도 원래의 인터페이스 설계를 자유롭게 확장할 수 있다.
예를 들어 자바 8에서는 List에 직접 sort 메서드를 호출할 수 있다. 이는 자바 8의 List 인터페이스에
다음과 같은 디폴트 메서드 정의가 추가되었기 때문이다.


default void sort(Comparator<? super E> c) {
    Collections.sort(this, c);
}

## 1.6 함수형 프로그래밍에서 가져온 다른 유용한 아이디어 💡

지금까지 자바에 포함된 함수형 프로그래밍의 핵심적인 두 아이디어를 살펴봤다.
하나는 메서드와 람다를 일급값으로 사용하는 것이고, 다른 하나는 가변 공유 상태가 없는 병렬 실행을 이용해서
효율적이고 안전하게 함수나 메서드를 호출할 수 있다는 것이다. 1.4절에서 설명한 스트림 API 는 이 두가지 아이디어를 모두 활용한다.
자바 8에서는 NullPointer 예외를 피할 수 있도록 도와주는 Optional<T> 클래스를 제공한다. Optional<T>는 값을 갖거나 갖지 않을 수 있는 컨테이너 객체다.

## 1.7 마치며 🏁

- 언어 생태계의 모든 언어는 변화해서 살아남거나 그대로 머물면서 사라지게 된다. 지금은 자바의 위치가 견고하지만 코볼과 같은 언어의 선례를 떠올리면 자바가 영원히 지배적인 위치를 유지할 수 있는 것은 아닐 수 있다.
- 자바 8은 프로그램을 더 효과적이고 간결하게 구현할 수 있는 새로운 개념과 기능을 제공한다.
- 기존의 자바 프로그래밍 기법으로는 멀티코어 프로세서를 온전히 활용하기 어렵다.
- 함수는 일급값이다. 메서드를 어떻게 함수형값으로 넘겨주는지, 익명 함수(람다)를 어떻게 구현하는지 기억하자.
- 자바 8의 스트림 개념 중 일부는 컬렉션에서 가져온 것이다. 스트림과 컬렉션을 적절하게 활용하면 스트림의 인수를 병렬로 처리할 수 있으며 더 가독성이 좋은 코드를 구현할 수 있다.
- 기존 자바 기능으로는 대규모 컴포넌트 기반 프로그래밍 그리고 진화하는 시스템의 인터페이스를 적절하게 대응하기 어려웠다. 자바 9에서는 모듈을 이용해 시스템의 구조를 만들 수 있고 디폴트 메소드를 이용해 기존 인터페이스를 구현하는 클래스를 바꾸지 않고도 인터페이스를 변경할 수 있다.
- 함수형 프로그래밍에서 null 처리 방법과 패턴 매칭 활용 등 흥미로운 기법을 발견했다.
